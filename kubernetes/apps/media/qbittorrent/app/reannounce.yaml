apiVersion: v1
kind: ConfigMap
metadata:
  name: qbittorrent-reannounce-script
data:
  reannounce.py: |
    #!/usr/bin/env python3
    import sys
    import os
    import time
    import json
    from urllib.request import Request, build_opener, HTTPCookieProcessor, URLError
    from urllib.parse import urlencode
    from http.cookiejar import CookieJar

    print("Starting reannounce script")

    # Config: Update intervals/attempts if needed
    host = 'http://localhost:80'
    username = os.getenv('QBT_USER')
    password = os.getenv('QBT_PASS')

    if not username or not password:
        print("Missing QBT_USER or QBT_PASS env vars!")
        sys.exit(1)

    if len(sys.argv) < 2:
        print("No torrent name provided")
        sys.exit(1)

    torrent_name = sys.argv[1]
    reannounce_interval = 7  # Seconds
    max_attempts = 20

    # Setup cookie handler for auth
    cj = CookieJar()
    opener = build_opener(HTTPCookieProcessor(cj))

    # Login to qBittorrent API
    login_data = urlencode({'username': username, 'password': password}).encode()
    login_req = Request(host + '/api/v2/auth/login', data=login_data, method='POST')
    try:
        with opener.open(login_req) as login_resp:
            if login_resp.read().decode() != 'Ok.':
                print("Login failed!")
                sys.exit(1)
    except URLError as e:
        print(f"Login connection failed: {e}")
        sys.exit(1)

    # Helper for API calls
    def api_call(path, params=None, method='GET'):
        url = host + '/api/v2/' + path
        data = None
        if params and method == 'POST':
            data = urlencode(params).encode()
        req = Request(url, data=data, method=method)
        try:
            with opener.open(req) as resp:
                content = resp.read().decode()
                if content:
                    try:
                        return json.loads(content)
                    except json.JSONDecodeError:
                        return content  # Fallback for plain text responses (e.g., "Ok.")
                return None
        except URLError as e:
            print(f"API call failed ({path}): {e}")
            return None

    # Find torrent hash by exact name match
    torrents = api_call('torrents/info')
    if not torrents:
        print("Failed to fetch torrents list!")
        sys.exit(1)

    torrent_hash = None
    for t in torrents:
        if t['name'] == torrent_name:
            torrent_hash = t['hash']
            break

    if not torrent_hash:
        print(f"Torrent '{torrent_name}' not found!")
        sys.exit(1)

    # Loop reannounce until unstalled or max attempts
    for attempt in range(max_attempts):
        info_list = api_call('torrents/info?hashes=' + torrent_hash)
        if not info_list:
            print("Failed to get torrent info")
            break
        info = info_list[0]
        state = info.get('state', 'unknown')
        if info.get('dlspeed', 0) > 0 or state not in ['stalledDL', 'stalledUP']:
            print(f"Unstalled after {attempt} attempts! (State: {state})")
            break

        # Force reannounce
        result = api_call('torrents/reannounce', {'hashes': torrent_hash}, 'POST')
        if result != 'Ok.':
            print(f"Reannounce failed: {result}")
        else:
            print(f"Reannounced (attempt {attempt + 1}/{max_attempts})")

        time.sleep(reannounce_interval)

    print("Done.")
