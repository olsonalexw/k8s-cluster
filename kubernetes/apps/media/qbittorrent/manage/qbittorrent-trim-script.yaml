apiVersion: v1
kind: ConfigMap
metadata:
  name: qbittorrent-trim-script
data:
  trim_seeders.py: |
    from qbittorrentapi import Client
    import os
    import time
    print("Starting trim script")

    # Connect to qBittorrent
    username = os.getenv('QBT_USER')
    password = os.getenv('QBT_PASS')
    if username and password:
        client = Client(host='qbittorrent.media.svc.cluster.local', port=80, username=username, password=password)
    else:
        raise ValueError("QBT_USER and QBT_PASS env vars must be set")

    # Constants
    MIN_RATIO = 1.1
    MIN_SEEDING_HOURS = 337
    MAX_SEEDERS = 15
    IPT_TAG = 'iptorrents'
    DRY_RUN = False  # Set to False to actually delete

    # Get all seeding torrents for IPT tag
    torrents = client.torrents_info(status_filter='seeding', tag=IPT_TAG)

    # Prepare data for each torrent
    torrent_data = []
    for t in torrents:
        seeding_hours = t.seeding_time / 3600.0
        productivity = (t.uploaded / 1e9) / max(seeding_hours, 1)  # GB/hour; avoid div0
        is_eligible = t.ratio >= MIN_RATIO or seeding_hours >= MIN_SEEDING_HOURS
        torrent_data.append((productivity, is_eligible, t.hash, t.name, seeding_hours, t.ratio, t.category))

    total = len(torrent_data)
    print(f"Total seeding torrents with tag '{IPT_TAG}': {total}")
    print("\nProductivity report:")
    print("-" * 80)
    print(f"{'Name':<50} {'Prod (GB/h)':<12} {'Hours':<8} {'Ratio':<6} {'Eligible'}")
    print("-" * 80)
    # Sort by productivity descending for nicer print (highest first)
    sorted_for_print = sorted(torrent_data, key=lambda x: x[0], reverse=True)
    for prod, eligible, hash_val, name, hours, ratio, category in sorted_for_print:
        print(f"{name[:49]:<50} {prod:<12.4f} {hours:<8.1f} {ratio:<6.3f} {eligible}")

    if total <= MAX_SEEDERS:
        print(f"\nTotal at or below {MAX_SEEDERS}; no deletions needed.")
    else:
        excess = total - MAX_SEEDERS
        print(f"\nExcess torrents: {excess}. Identifying candidates for deletion...")

        # Sort by productivity ascending (least productive first)
        sorted_torrents = sorted(torrent_data, key=lambda x: x[0])

        # Candidates are the least productive 'excess' torrents
        candidates = sorted_torrents[:excess]
        to_delete = []
        for prod, eligible, hash_val, name, hours, ratio, category in candidates:
            if not eligible:
                print(f"  Skipping {name[:50]} (prod: {prod:.4f} GB/h) - not eligible (ratio: {ratio:.3f}, hours: {hours:.1f})")
            elif category == "manual":
                print(f"  Skipping {name[:50]} (prod: {prod:.4f} GB/h) - manual category")
            else:
                to_delete.append((hash_val, name, prod))

        num_to_delete = len(to_delete)
        if num_to_delete > 0:
            print(f"\nEligible for deletion: {num_to_delete}")
            print("-" * 60)
            print(f"{'Name':<50} {'Prod (GB/h)'}")
            print("-" * 60)
            for hash_val, name, prod in sorted(to_delete, key=lambda x: x[2]):  # sort by prod asc for display
                if DRY_RUN:
                    print(f"Would delete: {name[:49]:<50} {prod:<12.4f}")
                else:
                    print(f"Deleting:    {name[:49]:<50} {prod:<12.4f}")
                    client.torrents_delete(delete_local_files=True, torrent_hashes=hash_val)
                    time.sleep(1)  # Avoid API flood
        else:
            print(f"\nNo eligible candidates among the {excess} least productive torrents; no deletions.")

        final_total = total - num_to_delete
        print(f"\nProcessed {total} torrents. Will have {final_total} seeding torrents remaining.")
